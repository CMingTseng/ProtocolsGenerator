\documentclass{spbau-diploma}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра математических и информационных технологий},
    title              = {Протоколы/Структурные типы в Kotlin},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = SE,
    author             = {Сташевский Леонид Евгеньевич},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Жарков Д.\,Буква.},
    reviewerPosition   = {ст. преп.},
    reviewer           = {Привалов А.\,И.},
    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    chairHead          = {Омельченко А.\,В.},
    % university = {САНКТ-ПЕТЕРБУРГСКИЙ АКАДЕМИЧЕСКИЙ УНИВЕРСИТЕТ},
    % faculty = {Центр высшего образования},
    % city = {Санкт-Петербург},
    % year             = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
В современных языках программирования существует много способов вводить отношение подтипизации. Самый популярный подход - это отношение наследования или номинальная типизация. В наследовании программист сам решает какой объект является наследником другого. На языке типов это означает что тип наследника является подтипом типа предка. Существует вариант автоматического вывода отношения подтипизации на основе интерфейса объектов. В процессе сборки, компилятор проверяет что используемый тип удовлетворяет ограничениям указанного типа. Такая система типов называется структурной. Такая типизация встречается в некоторых языках программирования: Go, семейство ML.

Номинальная типизация является простой, а следовательно и более распространённой. Она используется в таких языках как Java, C++, Kotlin. Вместе с простотой на программиста накладываются ограничения: при взаимодействии с кодом, который уже скомпилирован в библиотеку. Типы находящиеся в других модулях нельзя добавить в иерархию наследования, поэтому для них приходится писать и поддерживать типы-обёртки.

Существует другое решение, сохраняющее простоту и выразительность. Можно использовать номинальную типизацию в большинстве случаев, а там где необходима гибкость - использовать структурный тип. Такой подход сохранит совместимость с уже написанным кодом и позволит писать более выразительный код. В языке с номинальными типами структурные типы называют протоколами.

На данный момент набирает популярность язык Kotlin. В нём используется номинальная система типов. На момент написания его основной целевой платформой является виртуальная машина языка Java. Существуют несколько языков на основе JVM, в которых поддерживаются структурные типы. Например они поддерживаются языками Scala, Whiteoak.

\section*{Постановка задачи}
Цель данной работы - реализация поддержки протоколов в языке Kotlin. Для её достижения необходимо выполнить следующие задачи:
\begin{itemize}
    \item Исследование способов реализации структурных типов в JVM, существующие реализации и выяснение ограничений
    \item Реализация и тестирование прототипа
    \item Реализация проверки типов в компиляторе языка Kotlin
    \item Генерация кода для компилятора
    \item Поддержка раздельной компиляции
    \item Поддержка многопоточности
    \item Измерение производительности и оптимизация
\end{itemize}

\section{Обзор предметной области}
% структурная типизация и механизм проверки типов, приводится сравнение существующих реализаций протоколов в других языках программирования.
\subsection{Виртуальная машина Java}
% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]
В данном разделе рассматриваются особенности разработки комилятора для виртуальной машины Java(далее JVM). JVM - абстрактная виртуальная машина и набор библиотек. Существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. Все реализации полностью или частично придерживаются спецификации JVM. В ней описаны набор инструкций и их ожидаемое поведение, модель памяти, формат исполняемых файлов и т.п. JVM является стековой машиной: операнды методов и результат вызовов распологаются на стеке.
% ссылка на спеку

JVM поддерживает раздельную компиляцию. Единицей компиляции является классфайл. В классфайле находится тип, с указанием родительского класса, информация о родительских интерфейсах, поля и методы. Код метода содержит последовательность инструкций виртуальной машины. Классфайлы собираются в архивы формата jar.

\subsubsection{Байткод виртуальной машины}
Исходный код метода состоит из последовательность однобайтовых(иногда двухбайтовых) инструкций. Присутствуют инструкции для работы с локальными переменными, создания объектов и примитивных типов, арифметические операции, инструкции для вызова метода, условные переходы. Отсутствуют инструкции для прямой работы с памятью: нельзя взять указатель на определённый адрес или перейти к исполнению адреса. Аллоцированные объекты передаются по ссылкам.

Все инструкции строго типизированы. Есть два вида типов: примитивные типы передающиеся по значению и ссылочные типы. Примитивные типы заранее определены в JVM, пользовательские примитивные типы создать нельзя. Для каждого примитивного типа существует парный ссылочный тип, который используется в особых случаях. Существуют следующие типы примитивных типов: int, boolean, short. Парные ссылочные типы: Integer, Boolean, Short соответственно. В языке Kotlin такое разделение отсутствует. Программист пользуется встроенным типом, какой тип использовать решает компилятор.

В JVM встроен механизм исключений. В любом месте кода может быть написана инструкция, обозначающая исключительную ситуацию. При выполнении такой инструкции исполнение будет передано ближайшему блоку обработки исключений подходящего типа.

Большинство методов в JVM виртуальные, так же поддерживаются статические методы.
На уровне JVM поддерживается номинальная система типов и отношение наследования. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются invoke-инструкции. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у непроинициализированных объектов
    \item \textbf{invokevirtual} используется для вызова методов у класса
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвесен реальный тип объекта.

\textbf{Рефлексия}

Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. По имени и точной сигнатуре получить ссылку на метод и по ней сделать вызов. Вызов происходит с помощью метода invoke класса Method. Данный метод принимает объект на котором происходит вызов(далее ресивер) и массив с аргументами. Поиск метода может занимать длительное время. Вызов метода происходит дольше чем вызов с помощью invokevirtual поскольку при каждом вызове происходит заворачивание аргументов в массив и проверка типов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

% invokedynamic: boostrap method, lookup object, method handle
% рассказать про то что exception оборачивается
\textbf{Инструкция invokedynamic}
% JSR, MethodHandle
Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.


\subsection{Структурная и номинальная типизации}
В данном разделе рассмотрены основы структурной типизации и номинальной типизации.
% Тут расказ про проверку типов
% TAPL [19.3]
Плюсы номинальной типизации
\begin{itemize}
    \item быстрее во время выполнения
    \item помогает избежать случайных отношений
    \item проще объявлять рекурсивные типы
    \item быстрее проверять
\end{itemize}

Плюсы структурной типизации
\begin{itemize}
    \item замкнуты: тип содержит в себе всё описание
    \item имя типа имеет символический характер и не влияет на отношение типизации
\end{itemize}

\subsection{Существующие реализации протоколов}
В этом разделе проведён анализ существующих реализация протоколов, приведены плюсы и минусы различных подходов. В качетве реализаций рассмотрены языки: Scala, Go и прототип Whiteoak.

\subsubsection{Scala}
% Link to scala paper(Martin O)
Рассмотрим реализацию протоколов в языке Scala. Scala компилируется в JVM байткод. Реализацию можно разделить на 2 части: проверку типов при компиляции и вызов метода во время выполнения.

В скала всё устроено просто. Механизм проверки типов в скала достаточно мощный, поэтому достаточно просто отключить проверку на то, является ли один класс наследником другого. Протоколы не являются реальными типами, вместо них пишется тип Object. Когда необходимо вызвать метод или обратиться к полю, для каждого места вызова генерируется статический метод. Этот статический метод производит поиск метода через механизм рефлексии и производит вызов. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения. Таким образом вызов дополнительного метода выглядит прозрачно для пользователя. В месте вызова просто вызывается статический метод. Поиск метода может быть долгим, поэтому в реализации скала используют многоуровневое кэширование найденного метода. В связи с тем что во время выполнения отсутствуют типы - запрещено создание generic протоколов или использование в протоколах generic типов. Внимательное тестирование подхода, используемого в Scala показало что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на внешнюю корректность синтаксиса. Такое поведение связано с использованием примитивных типов в generic классах:

% souce code here

С точки зрения языка Scala такой код корректный. Он проходит проверку типов и компиляцию, но во время выполнения происходит искючительная ситуация. Причиной этому является не совпадение сигнатур методов. Во время генерации класса Impl тип T становится наиболее общим типом Object. В то же время для вызова в методе foo сгенерировался метод ищущий функции с типом Int. Поэтому в во время выполнения нужная функция в объекте Impl отсутствует и происходит исключение.


% Рассказ про кэш

Вызов метода устроен с помощью механизма рефлексии.
\subsubsection{Whiteoak}
\subsubsection{Go}

\section{Реализация}
\subsection{Прототип}
\subsection{Производительность}
%\subsubsection{Случай одного ресивера}
%\subsubsection{Случай нескольких ресиверов}

% У заключения нет номера главы
\section*{Заключение}

\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
