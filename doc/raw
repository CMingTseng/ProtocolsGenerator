
Bytecode
В JVM встроен механизм исключений. В любом месте кода может быть написана инструкция, обозначающая исключительную ситуацию. При выполнении такой инструкции исполнение будет передано ближайшему блоку обработки исключений подходящего типа.

Reflection
Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

Scala

В скала всё устроено просто. Механизм проверки типов в скала достаточно мощный, поэтому достаточно просто отключить проверку на то, является ли один класс наследником другого. Протоколы не являются реальными типами, вместо них пишется тип Object. Когда необходимо вызвать метод или обратиться к полю, для каждого места вызова генерируется статический метод. Этот статический метод производит поиск метода через механизм рефлексии и производит вызов. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения. Таким образом вызов дополнительного метода выглядит прозрачно для пользователя. В месте вызова просто вызывается статический метод. Поиск метода может быть долгим, поэтому в реализации скала используют многоуровневое кэширование найденного метода. В связи с тем что во время выполнения отсутствуют типы - запрещено создание generic протоколов или использование в протоколах generic типов. Внимательное тестирование подхода, используемого в Scala показало что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на внешнюю корректность синтаксиса. Такое поведение связано с использованием примитивных типов в generic классах:

/*
source code:
class Impl[T] {
	fun x(i: T): T = i
}

class Main {
	type Proto = { def x(i: Int): Int }

	fun foo(arg: Proto) {
		print(arg.x(42))
	}

	fun main(args: Array[String]) {
		foo(Impl[Int]())
	}
}
*/
С точки зрения языка Scala такой код корректный. Он проходит проверку типов и компиляцию, но во время выполнения происходит искючительная ситуация. Причиной этому является не совпадение сигнатур методов. Во время генерации класса Impl тип T становится наиболее общим типом Object. В то же время для вызова в методе foo сгенерировался метод ищущий функции с типом Int. Поэтому в во время выполнения нужная функция в объекте Impl отсутствует и происходит исключение.


Структурная и номинальная типизации

Плюсы номинальной типизации
 - быстрее во время выполнения
 - помогает избежать случайных отношений
 - проще объявлять рекурсивные типы
 - быстрее проверять

Плюсы структурной типизации
 - замкнуты: тип содержит в себе всё описание
 - имя типа имеет символический характер и не влияет на отношение типизации

Whiteoak
Whiteoak это расширение языка java с целью добавить в язык поддержку протоколов. --- Тут идёт абзац про динамическую генерацию кода.--- Так как во время выполнения не доступна информация о параметрическом полиморфизе, то протоколы Whiteoak не поддерживают использование generic типов, например они не могут быть элементами generic коллекций.

Резюме по обзору решений:
Таблица в которой обозначены различные критерии и обозреваемые реализации с плюсами минусами.

Мораль и итог
Все решения имеют некоторые плюсы и минусы, попытаемся объеденить их плюсы и исключить минусы тратата.